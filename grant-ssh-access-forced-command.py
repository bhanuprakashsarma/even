#!/usr/bin/env python3
'''
Grant SSH access for a given user by fetching his public key from the server.

This script should be used as SSH forced command.
'''

import argparse
import datetime
import os
import pwd
import re
import requests
import shlex
import subprocess
import sys
import syslog
import tempfile
import yaml

from pathlib import Path


USER_NAME_PATTERN = re.compile('^[a-z][a-z0-9-]{0,31}$')

CONFIG_FILE_PATH = Path('/etc/ssh-access-granting-service.yaml')

MARKER = '(generated by SSH Access Granting Service)'

WELCOME_MESSAGE = 'Your SSH access was granted by SSH Access Granting Service on {date}'
REVOKED_MESSAGE = 'Your SSH access was revoked by SSH Access Granting Service on {date}'
USER_COMMENT = 'SSH user created by SSH Access Granting Service on {date}'

DEFAULT_SHELL = '/bin/bash'


def date():
    now = datetime.datetime.now()
    return now.strftime('%Y-%m-%d %H:%M:%S')


def fix_ssh_pubkey(user: str, pubkey: str):
    '''Validate that the given public SSH key looks like a valid OpenSSH key which can be used in authorized_keys'''

    pubkey = pubkey.strip()
    parts = pubkey.split()[:2]  # just the type and the key, the "mail" is probably wrong
    if not parts:
        raise ValueError('Invalid SSH public key... the key is empty')
    if not (parts[0].startswith('ssh-') or parts[0].startswith('ecdsa-')):
        raise ValueError('Invalid SSH public key... no "rsa", "dsa" or "ecdsa" key...')

    # TODO? check if it can be base64 decoded?
    if len(parts[1]) % 4:
        raise ValueError('Invalid SSH public key... length modulo 4 is not 0')

    pubkey = ' '.join(parts)
    if pubkey.find('@') != -1:
        raise ValueError('Invalid SSH public key... no space between key and mail address')

    # add user name as comment
    pubkey += ' %s' % user
    return pubkey


def get_config():
    if CONFIG_FILE_PATH.exists():
        with CONFIG_FILE_PATH.open('rb') as fd:
            config = yaml.safe_load(fd)
    else:
        config = yaml.safe_load(subprocess.check_output(['sudo', 'cat', '/var/lib/cloud/instance/user-data.txt']))
    return config


def get_service_url():
    '''Get the service URL from the global config file or from cloud config YAML'''

    config = get_config()

    url = config['ssh_access_granting_service_url'].rstrip('/')
    return url


def download_public_key(url, name):
    '''Download the SSH public key for the given user name from URL'''

    r = requests.get('{url}/public-keys/{name}/sshkey.pub'.format(url=url, name=name))
    r.raise_for_status()
    pubkey = fix_ssh_pubkey(name, r.text)
    return pubkey


def add_our_mark(pubkey):
    return '{} {}'.format(pubkey, MARKER)


def add_forced_command(pubkey, forced_command):
    return 'command="{}" {}'.format(forced_command, pubkey)


def get_keys_file_path(user_name: str) -> Path:
    pw_entry = pwd.getpwnam(user_name)

    ssh_dir = Path(pw_entry.pw_dir) / '.ssh'
    keys_file = ssh_dir / 'authorized_keys'
    return keys_file


def generate_authorized_keys(user_name: str, keys_file: Path, pubkey: str, forced_command: str):
    ssh_dir = keys_file.parent
    subprocess.check_call(['sudo', 'mkdir', '-p', str(ssh_dir)])
    subprocess.check_call(['sudo', 'chown', user_name, str(ssh_dir)])
    subprocess.check_call(['sudo', 'chmod', '700', str(ssh_dir)])

    with tempfile.NamedTemporaryFile(suffix='{name}-sshkey.pub'.format(name=user_name)) as fd:
        fd.write(add_our_mark(add_forced_command(pubkey, forced_command)).encode('utf-8'))
        fd.flush()
        shell_template = 'cat {temp} > {keys_file} && chown {name} {keys_file} && chmod 600 {keys_file}'
        subprocess.check_call(['sudo', 'sh', '-c',
                              shell_template.format(temp=fd.name, name=user_name, keys_file=keys_file)])


def grant_ssh_access(args):
    user_name = args.name

    url = get_service_url()
    pubkey = download_public_key(url, user_name)

    try:
        pwd.getpwnam(user_name)
    except:
        config = get_config()
        subprocess.check_call(['sudo', 'useradd', '--user-group',
                               '--groups', ','.join(config.get('user_groups', ['adm'])),
                               '--comment', USER_COMMENT.format(date=date()), user_name])

    keys_file = get_keys_file_path(user_name)

    forced_command = 'echo {}; {}'.format(shlex.quote(WELCOME_MESSAGE.format(date=date())), DEFAULT_SHELL)
    generate_authorized_keys(user_name, keys_file, pubkey, forced_command)


def is_generated_by_us(keys_file):
    '''verify that the user was created by us'''
    output = subprocess.check_output(['sudo', 'cat', str(keys_file)])
    return MARKER.encode('utf-8') in output


def revoke_ssh_access(args: list):
    user_name = args.name

    url = get_service_url()
    pubkey = download_public_key(url, user_name)

    keys_file = get_keys_file_path(user_name)

    if not is_generated_by_us(keys_file):
        sys.stderr.write('Cannot revoke SSH access from user "{}": ' +
                         'the user was not created by this script.\n'.format(user_name))
        sys.exit(2)

    forced_command = 'echo {}'.format(shlex.quote(REVOKED_MESSAGE.format(date=date())))
    generate_authorized_keys(user_name, keys_file, pubkey, forced_command)


def fail_on_missing_command():
    sys.stderr.write('Missing command argument\n')
    sys.exit(1)


def user_name(val: str):
    '''Validate user name parameter'''

    if not USER_NAME_PATTERN.match(val):
        raise argparse.ArgumentTypeError('Invalid user name')
    return val


def main(argv: list):
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers()
    cmd = subparsers.add_parser('grant-ssh-access')
    cmd.set_defaults(func=grant_ssh_access)
    cmd.add_argument('name', help='User name', type=user_name)
    cmd = subparsers.add_parser('revoke-ssh-access')
    cmd.set_defaults(func=revoke_ssh_access)
    cmd.add_argument('name', help='User name', type=user_name)
    args = parser.parse_args(argv)

    if not hasattr(args, 'func'):
        fail_on_missing_command()

    syslog.openlog(ident=os.path.basename(__file__), logoption=syslog.LOG_PID, facility=syslog.LOG_AUTH)
    syslog.syslog(' '.join(argv))
    args.func(args)


if __name__ == '__main__':
    original_command = os.environ.get('SSH_ORIGINAL_COMMAND')
    if original_command:
        sys.argv[1:] = original_command.split()

    main(sys.argv[1:])
